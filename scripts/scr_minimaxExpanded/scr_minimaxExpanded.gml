// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information


function miniMaxExpanded(p2_pieces){
	
	//we do not need a root node as it is just the normal gameboard that we will use
	
	//We want to make a backup copy as we will be modifying the board states throughout the process
	var pieceLocationBackup = ds_grid_create(8,8); //backup of our traditional piece locations grid 
	ds_grid_copy(pieceLocationBackup, obj_chessController.pieceLocations); //make the backup copy that we can use to restore the board at the end of the entire loops
	
	
	//Now we will have a copy that we use throughout our game too
	var seenGameBoard = ds_grid_create(8,8); //backup of our traditional piece locations grid 
	ds_grid_copy(seenGameBoard, obj_chessController.pieceLocations); //make the backup copy that we can use to restore the board at the end of the entire loops

	
	//Now we can worry about the AI movement "tree" layer 
	
	//we will figure out how many moves the AI can make, as they are all derivative states from what our default board state is 
	var numberOfAIMoves = 0;
	
	//first we will make a copy of the p2 pieces so we have a modifiable copy if desired 
	var p2Pieces = [array_length(p2_pieces)];
	array_copy(p2Pieces, 0, p2_pieces, 0, array_length(p2_pieces))
	
	
	//To do this, we will iterate through the p2 pieces and generate the moves they can make 
	for(var i = 0; i < array_length(p2Pieces); i++){
		
		var currentPiece = p2Pieces[i];
		var xPos = currentPiece.xPos;
		var yPos = currentPiece.yPos;
		
		//generate the validMoves of the current piece
		
		//now generate the moves that the piece can conduct 
		if(currentPiece.pieceType == "P"){
				scr_pawnMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove,  currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}else if(currentPiece.pieceType == "R"){
				scr_rookMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}else if(currentPiece.pieceType == "K"){
				scr_knightMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}else if(currentPiece.pieceType == "B"){
			scr_bishopMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}else if(currentPiece.pieceType == "Q"){
				scr_queenMoves(currentPiece.validMoves, xPos, yPos, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}else if(currentPiece.pieceType == "W"){
				scr_kingMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
		}
		
		//now add the number of moves 
		numberOfAIMoves += ds_list_size(currentPiece.validMoves);
	}
	
	
	//Now to create an 2D grid that stores the board, the piece to move, and the square that is associated with 
	//[nx3] (3 rows, n columns)
	//row 0: store the board state that is generated by the move;  row 1: store the piece that made the move to build it, row 2: store the square it moved to 
	// row 1 and 2 are used to choose the piece and square to move to after the analysis is done 
	aiBoardArray = ds_grid_create(numberOfAIMoves, 3);
	
	//now to build a tracker for what index we are adding to 
	var moveCounter = 0; 
	
	
	//Now we will have a copy for AI start
	var startAIBoard = ds_grid_create(8,8); //backup of our traditional piece locations grid 
	ds_grid_copy(startAIBoard, obj_chessController.pieceLocations); //make the backup copy that we can use to restore the board at the end of the entire loops
	
	//Now iterate through the p2 pieces, as we will use each piece and each move to generate new boards 
	for(var i = 0; i < array_length(p2Pieces); i++){
		
		//capture the current piece and make a copy of it 
		var currentPieceOfInterest = p2Pieces[i];
		var backupPieceOfInterest = p2Pieces[i]; //used to restore values 
		
		var saveXLocation = currentPieceOfInterest.xPos;
		var saveYLocation = currentPieceOfInterest.yPos;
		
		var boardToModify = ds_grid_create(1,1);
		ds_grid_copy(boardToModify, startAIBoard); 
		
		
	
		
		
		//Now iterate through this piece's validMoves that it generated before 
		for(var j = 0; j < ds_list_size(currentPieceOfInterest.validMoves); j++){
		
			//restore the current piece just in case 
			currentPieceOfInterest = backupPieceOfInterest;
			currentPieceOfInterest.xPos = saveXLocation;
			currentPieceOfInterest.yPos = saveYLocation;
			
			
			//reset the board we are analyzing from 
			ds_grid_copy(boardToModify, startAIBoard);
			
			//capture the current move of the piece and their positions 
			var currentMove = currentPieceOfInterest.validMoves[| j];
			var moveXPostion = currentMove.xPos;
			var moveYPostion = currentMove.yPos;
			
		
			
			//now to shift positions by setting both to noone, and  then placing the piece 
			ds_grid_set(boardToModify, moveXPostion, moveYPostion, noone); 
			ds_grid_set(boardToModify, currentPieceOfInterest.xPos, currentPieceOfInterest.yPos, noone);
			ds_grid_set(boardToModify, moveXPostion, moveYPostion, currentPieceOfInterest); //set the current piece into the location
			
			
			//adjust the pieces location
			boardToModify[# moveXPostion, moveYPostion].xPos = moveXPostion;
			boardToModify[# moveXPostion, moveYPostion].yPos = moveYPostion;
			boardToModify[# moveXPostion, moveYPostion].firstMove = false;

			
			//now the grid should be updated with the AI movement 
			
			//restore the piece just to make sure it is starting from valid position when selected
			currentPieceOfInterest = backupPieceOfInterest;
			currentPieceOfInterest.xPos = saveXLocation;
			currentPieceOfInterest.yPos = saveYLocation;
			
			
			
			
			//we now load the board into the array along with the piece, etc
			copyBoard = ds_grid_create(1,1);
			ds_grid_copy(copyBoard, boardToModify);
			ds_grid_set(aiBoardArray, moveCounter, 0, copyBoard)
			ds_grid_set(aiBoardArray, moveCounter, 1, currentPieceOfInterest);
			ds_grid_set(aiBoardArray, moveCounter, 2, currentMove);
			
			//increment move counter so we can move through the array properly to store other pieces in their appropriate index
			moveCounter++; 
		}
	}
	
	//at this point it should be filled enough, not sure if it actually is though... let's find out
	
	/*
	
	//DEBUG STATEMENTS TO SEE THE BOARD FILL OUT PROPERLY, SEEMS TO WORK HERE!
	show_debug_message(aiBoardArray[# 0, 0][# 0, 0])

	for(var i = 0; i < ds_grid_width(aiBoardArray); i++){
	
		var currentDrawBoard = aiBoardArray[# i, 0];
		show_debug_message("CURRENT BOARD INFO")
		show_debug_message(ds_grid_width(currentDrawBoard))
		show_debug_message(ds_grid_height(currentDrawBoard))
		
		for(var j = 0; j < ds_grid_width(currentDrawBoard); j++){
			for(var k = 0; k < ds_grid_height(currentDrawBoard); k++){
				
				if(currentDrawBoard[# j, k ] == noone){
					show_debug_message("-")
				}else{
				

				show_debug_message(string(currentDrawBoard[# j, k].pieceType) + string(currentDrawBoard[# j, k].piecePlayer))
				}
			}	
		}
		
	}
	*/
	
	
	//Now we need to generate how many moves occur on the human's next turn
	
	var numberOfHumanMoves = 0;
	
	//iterate through all of the AI boards as we need to generate the count for each set of moves 
	for(var i = 0; i < numberOfAIMoves; i++){
	
		//get the board so we have the curernt AI's situation
		var analyzedBoard = ds_grid_create(1,1);
		ds_grid_copy(analyzedBoard, aiBoardArray[# i, 0]);
		
		//NOW WE SET THE CHESSCONTROL BOARD TO THIS BOARD, SO WE HAVE THE ABILITY TO USE THE SCRIPTS AS PROVIDED
		ds_grid_copy(obj_chessController.pieceLocations, analyzedBoard);
		
		
		//We also need to get the p1 pieces of interest for THIS BOARD, iterates across all possible AI boards to do the move calculations
		var p1AnalysisPieces = [];
		
		for(var j = 0; j < 8; j++){
			
			for(var k = 0; k < 8; k++){
				
				if(analyzedBoard[# j, k] == noone){
					continue;
				}
				
				if(analyzedBoard[# j, k].piecePlayer == 1){
					array_push(p1AnalysisPieces, analyzedBoard[# j, k]);	
				}		
			}	
		}
		
		var currentBoardCount = 0;
		
		//Now we iterate through this array and generate the moves
		for(var j = 0; j < array_length(p1AnalysisPieces); j++){
			
			var currentPiece = p1AnalysisPieces[j];
			var xPos = currentPiece.xPos;
			var yPos = currentPiece.yPos;
		
			//generate the validMoves of the current piece
		
			//now generate the moves that the piece can conduct 
			if(currentPiece.pieceType == "P"){
				scr_pawnMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove,  currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "R"){
				scr_rookMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "K"){
				scr_knightMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "B"){
				scr_bishopMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "Q"){
				scr_queenMoves(currentPiece.validMoves, xPos, yPos, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "W"){
				scr_kingMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}
		
			//now add the number of moves 
			numberOfHumanMoves += ds_list_size(currentPiece.validMoves);
			currentBoardCount += ds_list_size(currentPiece.validMoves);
		}	
		
		//show_debug_message("THIS BOARD'S MOVES ARE " + string(currentBoardCount))
	}
	
	//Now we will create the list for the human move variations, the next tier in our "tree" implemented via arrays
	
	//Create a 2D grid that will follow the following conventions in this function
	//[n x 5] (5 row n column (boards))
	//In the row direction: 0 will store the modified board state, 1 will store the score status, 2 will hold piece that selected, and 4 holds the square it moves to, 5 holds the index of the previous array
	
	//store the root in the root array and add information to it 
	humanBoardArray = ds_grid_create(numberOfHumanMoves, 5);
	
	
	var moveCounter = 0;	
	//now we will iterate through every board that the AI can generate 
	for(var i = 0; i < ds_grid_width(aiBoardArray); i++){
		
		
		//create a board that we will modify, and create a backup for it 
		var modifyBoard = ds_grid_create(1,1);
		ds_grid_copy(modifyBoard, aiBoardArray[# i, 0]);
		
		var backupOfBoardToModify = ds_grid_create(1,1);
		ds_grid_copy(backupOfBoardToModify, aiBoardArray[# i, 0]);
		
		//now we will calculate how many pieces there are for this speciifc board from p1 pieces
		var p1Pieces= [];
		
		for(var j = 0; j < 8; j++){
			
			for(var k = 0; k < 8; k++){
				
				if(modifyBoard[# j, k] == noone){
					continue;
				}
				
				if(modifyBoard[# j, k].piecePlayer == 1){
					array_push(p1Pieces, modifyBoard[# j, k]);	
				}		
			}	
		}
		
		//now set the piece locations that we build moves off of to the board we are anlayzing 
		
		ds_grid_copy(obj_chessController.pieceLocations, modifyBoard);
		
		//Now we iterate through each piece that is p1 pieces and generate the moves
		for(var j = 0; j < array_length(p1Pieces); j++){
			
			var currentPiece = p1Pieces[j];
			var xPos = currentPiece.xPos;
			var yPos = currentPiece.yPos;
		
			//generate the validMoves of the current piece
		
			//now generate the moves that the piece can conduct 
			if(currentPiece.pieceType == "P"){
				scr_pawnMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove,  currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "R"){
				scr_rookMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "K"){
				scr_knightMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "B"){
				scr_bishopMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "Q"){
				scr_queenMoves(currentPiece.validMoves, xPos, yPos, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "W"){
				scr_kingMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}
		}	
		
		//now we have a list of piece and the updated moves for them 
		
		//we now will iterate through the pieces themselves 
		for(var j = 0; j < array_length(p1Pieces); j++){
			
			
			//capture the current piece and make a copy of it 
			var currentPieceOfInterest = p1Pieces[j];
			var backupPieceOfInterest = p1Pieces[j]; //used to restore values 
		
			var saveXLocation = currentPieceOfInterest.xPos;
			var saveYLocation = currentPieceOfInterest.yPos;
		
			var boardToModify = ds_grid_create(1,1);
			ds_grid_copy(boardToModify, modifyBoard); 
				
	
			//we also iterate through each piece for each board 
			for(var k =0; k < ds_list_size(currentPieceOfInterest.validMoves); k++){
				
				//restore the current piece just in case 
				currentPieceOfInterest = backupPieceOfInterest;
				currentPieceOfInterest.xPos = saveXLocation;
				currentPieceOfInterest.yPos = saveYLocation;
				
				//reset the board we are analyzing from 
				ds_grid_copy(boardToModify, modifyBoard);
				
				//capture the current move of the piece and their positions 
				var currentMove = currentPieceOfInterest.validMoves[| k];
				var moveXPostion = currentMove.xPos;
				var moveYPostion = currentMove.yPos;
				
				
				//now to shift positions by setting both to noone, and  then placing the piece 
				ds_grid_set(boardToModify, moveXPostion, moveYPostion, noone); 
				ds_grid_set(boardToModify, currentPieceOfInterest.xPos, currentPieceOfInterest.yPos, noone);
				ds_grid_set(boardToModify, moveXPostion, moveYPostion, currentPieceOfInterest); //set the current piece into the location
				
				
				
			//adjust the pieces location
			boardToModify[# moveXPostion, moveYPostion].xPos = moveXPostion;
			boardToModify[# moveXPostion, moveYPostion].yPos = moveYPostion;
			

			
			//now the grid should be updated with the AI movement 
			
			//restore the piece just to make sure it is starting from valid position when selected
			currentPieceOfInterest = backupPieceOfInterest;
			currentPieceOfInterest.xPos = saveXLocation;
			currentPieceOfInterest.yPos = saveYLocation;
			
			
			//we now load the board into the array along with the piece, etc
			copyBoard = ds_grid_create(1,1);
			ds_grid_copy(copyBoard, boardToModify);
			ds_grid_set(humanBoardArray, moveCounter, 0, copyBoard)
			ds_grid_set(humanBoardArray, moveCounter, 1, scoreBoard(boardToModify))		
			ds_grid_set(humanBoardArray, moveCounter, 2, currentPieceOfInterest);
			ds_grid_set(humanBoardArray, moveCounter, 3, currentMove);
			ds_grid_set(humanBoardArray, moveCounter, 4, i);
			
			moveCounter++;		
				
			}
			
		}
	}
	
	
	//NOW TO DO ONE MORE AI LEVEL TO BE EVEN SMARTER
	
	/*
	############################################################
	############################################################
	############################################################
	############################################################	
	*/
	var numberOfAIMoves2= 0;
	
	//iterate through all of the AI boards as we need to generate the count for each set of moves 
	for(var i = 0; i < numberOfHumanMoves; i++){
	
		//get the board so we have the curernt AI's situation
		var analyzedBoard = ds_grid_create(1,1);
		ds_grid_copy(analyzedBoard, humanBoardArray[# i, 0]);
		
		//NOW WE SET THE CHESSCONTROL BOARD TO THIS BOARD, SO WE HAVE THE ABILITY TO USE THE SCRIPTS AS PROVIDED
		ds_grid_copy(obj_chessController.pieceLocations, analyzedBoard);
		
		
		//We also need to get the p1 pieces of interest for THIS BOARD, iterates across all possible AI boards to do the move calculations
		var p2AnalysisPieces = [];
		
		for(var j = 0; j < 8; j++){
			
			for(var k = 0; k < 8; k++){
				
				if(analyzedBoard[# j, k] == noone){
					continue;
				}
				
				if(analyzedBoard[# j, k].piecePlayer == 2){
					array_push(p2AnalysisPieces, analyzedBoard[# j, k]);	
				}		
			}	
		}
		
		var currentBoardCount = 0;
		
		//Now we iterate through this array and generate the moves
		for(var j = 0; j < array_length(p2AnalysisPieces); j++){
			
			var currentPiece = p2AnalysisPieces[j];
			var xPos = currentPiece.xPos;
			var yPos = currentPiece.yPos;
		
			//generate the validMoves of the current piece
		
			//now generate the moves that the piece can conduct 
			if(currentPiece.pieceType == "P"){
				scr_pawnMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove,  currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "R"){
				scr_rookMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "K"){
				scr_knightMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "B"){
				scr_bishopMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "Q"){
				scr_queenMoves(currentPiece.validMoves, xPos, yPos, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "W"){
				scr_kingMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}
		
			//now add the number of moves 
			numberOfAIMoves2 += ds_list_size(currentPiece.validMoves);
			currentBoardCount += ds_list_size(currentPiece.validMoves);
		}	
		
		//show_debug_message("THIS BOARD'S MOVES ARE " + string(currentBoardCount))
	}
	
	//Now we will create the list for the human move variations, the next tier in our "tree" implemented via arrays
	
	//Create a 2D grid that will follow the following conventions in this function
	//[n x 5] (5 row n column (boards))
	//In the row direction: 0 will store the modified board state, 1 will store the score status, 2 will hold piece that selected, and 4 holds the square it moves to, 5 holds the index of the previous array
	
	//store the root in the root array and add information to it 
	aiBoardArray2 = ds_grid_create(numberOfAIMoves2, 5);
	
	
	var moveCounter = 0;	
	//now we will iterate through every board that the AI can generate 
	for(var i = 0; i < ds_grid_width(humanBoardArray); i++){
		
		
		//create a board that we will modify, and create a backup for it 
		var modifyBoard = ds_grid_create(1,1);
		ds_grid_copy(modifyBoard, humanBoardArray[# i, 0]);
		
		var backupOfBoardToModify = ds_grid_create(1,1);
		ds_grid_copy(backupOfBoardToModify, humanBoardArray[# i, 0]);
		
		//now we will calculate how many pieces there are for this speciifc board from p1 pieces
		var p2Pieces= [];
		
		for(var j = 0; j < 8; j++){
			
			for(var k = 0; k < 8; k++){
				
				if(modifyBoard[# j, k] == noone){
					continue;
				}
				
				if(modifyBoard[# j, k].piecePlayer == 2){
					array_push(p2Pieces, modifyBoard[# j, k]);	
				}		
			}	
		}
		
		//now set the piece locations that we build moves off of to the board we are anlayzing 
		
		ds_grid_copy(obj_chessController.pieceLocations, modifyBoard);
		
		//Now we iterate through each piece that is p1 pieces and generate the moves
		for(var j = 0; j < array_length(p2Pieces); j++){
			
			var currentPiece = p2Pieces[j];
			var xPos = currentPiece.xPos;
			var yPos = currentPiece.yPos;
		
			//generate the validMoves of the current piece
		
			//now generate the moves that the piece can conduct 
			if(currentPiece.pieceType == "P"){
				scr_pawnMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove,  currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "R"){
				scr_rookMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "K"){
				scr_knightMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "B"){
				scr_bishopMoves(xPos, yPos, currentPiece.validMoves, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "Q"){
				scr_queenMoves(currentPiece.validMoves, xPos, yPos, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}else if(currentPiece.pieceType == "W"){
				scr_kingMoves(xPos, yPos, currentPiece.validMoves, currentPiece.firstMove, currentPiece.extraCheckMoves, currentPiece.piecePlayer, currentPiece.forCheck);
			}
		}	
		
		//now we have a list of piece and the updated moves for them 
		
		//we now will iterate through the pieces themselves 
		for(var j = 0; j < array_length(p2Pieces); j++){
			
			
			//capture the current piece and make a copy of it 
			var currentPieceOfInterest = p2Pieces[j];
			var backupPieceOfInterest = p2Pieces[j]; //used to restore values 
		
			var saveXLocation = currentPieceOfInterest.xPos;
			var saveYLocation = currentPieceOfInterest.yPos;
		
			var boardToModify = ds_grid_create(1,1);
			ds_grid_copy(boardToModify, modifyBoard); 
				
	
			//we also iterate through each piece for each board 
			for(var k =0; k < ds_list_size(currentPieceOfInterest.validMoves); k++){
				
				//restore the current piece just in case 
				currentPieceOfInterest = backupPieceOfInterest;
				currentPieceOfInterest.xPos = saveXLocation;
				currentPieceOfInterest.yPos = saveYLocation;
				
				//reset the board we are analyzing from 
				ds_grid_copy(boardToModify, modifyBoard);
				
				//capture the current move of the piece and their positions 
				var currentMove = currentPieceOfInterest.validMoves[| k];
				var moveXPostion = currentMove.xPos;
				var moveYPostion = currentMove.yPos;
				
				
				//now to shift positions by setting both to noone, and  then placing the piece 
				ds_grid_set(boardToModify, moveXPostion, moveYPostion, noone); 
				ds_grid_set(boardToModify, currentPieceOfInterest.xPos, currentPieceOfInterest.yPos, noone);
				ds_grid_set(boardToModify, moveXPostion, moveYPostion, currentPieceOfInterest); //set the current piece into the location
				
				
				
			//adjust the pieces location
			boardToModify[# moveXPostion, moveYPostion].xPos = moveXPostion;
			boardToModify[# moveXPostion, moveYPostion].yPos = moveYPostion;
			

			
			//now the grid should be updated with the AI movement 
			
			//restore the piece just to make sure it is starting from valid position when selected
			currentPieceOfInterest = backupPieceOfInterest;
			currentPieceOfInterest.xPos = saveXLocation;
			currentPieceOfInterest.yPos = saveYLocation;
			
			
			//we now load the board into the array along with the piece, etc
			copyBoard = ds_grid_create(1,1);
			ds_grid_copy(copyBoard, boardToModify);
			ds_grid_set(aiBoardArray2, moveCounter, 0, copyBoard)
			ds_grid_set(aiBoardArray2, moveCounter, 1, scoreBoard(boardToModify))		
			ds_grid_set(aiBoardArray2, moveCounter, 2, currentPieceOfInterest);
			ds_grid_set(aiBoardArray2, moveCounter, 3, currentMove);
			ds_grid_set(aiBoardArray2, moveCounter, 4, i);
			
			moveCounter++;		
				
			}
			
		}
	}
		
	
	var highestAIScore = [numberOfHumanMoves]; //create an empty array of moves that are good for the AI to take 
	
	//now we will iterate through each of the AI boards and find the min for that board
	for(var i = 0; i < numberOfHumanMoves; i++){
		
		var maxValue = -20000; //set to high so we know we can fill in vlaue 
		
		for(var j = 0; j < numberOfAIMoves2; j++){

			//if we are at a lower value and we are seeing an entry associated with it 
			if(aiBoardArray2[# j, 1] > maxValue && aiBoardArray2[# j, 4] == i){
				maxValue = aiBoardArray2[# j, 1];
			}
		}
		
		//place the value into the array at the location of the board, as we found the minimum 
		highestAIScore[i] = maxValue;
	}
	
	show_debug_message("highest SCORES ARE")
	for(var i = 0; i < array_length(highestAIScore); i++){
		
		show_debug_message(highestAIScore[i])
		
	}
	
	
	//now to decide which board we want to go towards, based on the worst case that we have captured
	
	var maxValue = -90000;
	var bestMoves = []; //array to hold the moves our AI would be okay taking 
	
	for(var i = 0; i < array_length(highestAIScore); i++){
		
		if(highestAIScore[i] > maxValue){
			
			maxValue = 	highestAIScore[i];
		}
	}
	
	
	show_debug_message("THE MAX VALUE WAS")
	show_debug_message(maxValue)
	
	for(var i = 0; i < array_length(highestAIScore); i++){
		
		if(highestAIScore[i] == maxValue){
			
			array_push(bestMoves, i)
		}
	}
	
	//now we have a list of indices that provide a maximum score to the second layer of the tree
	//need to point up one more 
	for(var i = 0; i < array_length(bestMoves); i++){
		
		//replace the value with the next pointer up 
		bestMoves[i] = humanBoardArray[# i, 4];
		
	}

	
	
	
	
	show_debug_message("SIZE OF THE INTEREST GRID")
	show_debug_message(ds_grid_width(pieceLocationBackup));
	show_debug_message(ds_grid_height(pieceLocationBackup));
	
	//RESTORE THE GAMEBOARD STATE
	ds_grid_copy(obj_chessController.pieceLocations, pieceLocationBackup);
	
	
	//now to randomly select moves from this list 
	randomize();
	var chooseMove = irandom(array_length(bestMoves) - 1);
	var chosenIndex = bestMoves[chooseMove];
	
	show_debug_message("THE CHOSEN INDEX IS ")
	show_debug_message(chosenIndex)

	
	//now grab that piece and square
	aiSelectedPiece = aiBoardArray[# chosenIndex, 1];
	obj_chessController.selectedPiece = aiSelectedPiece;
	chosenSquare = aiBoardArray[# chosenIndex, 2];
	
	
	
	show_debug_message("THE AI CHOSE")
	show_debug_message(aiSelectedPiece)
	show_debug_message(aiSelectedPiece.xPos)
	show_debug_message(aiSelectedPiece.yPos)
	show_debug_message(chosenSquare)
	
	//selectRandomPiece();
	//selectRandomSpace();
	
	
	
}

